{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Shuo Chen's notes on Linux TCP/IP stack Source of this site: https://github.com/chenshuo/tcpip-study The TCP state machine has three TCP/IP Reference TCP/IP Illustrated (vol. 1): The Protocols, 2nd ed. by Kevin R. Fall and W. Richard Stevens , 2011/11. RFC793 Transmission Control Protocol, 1981/09 RFC896 Nagle algorithm, 1984/01. Minshall's update . RFC1122 Requirements for Internet Hosts --- Communication Layers, 1989/10 RFC5681 TCP Congestion Control, 2009/09 RFC6093 On the Implementation of the TCP Urgent Mechanism, 2011/01, which recommends against the use of urgent mechanism. RFC7323 TCP Extensions for High Performance, obsoletes RFC1323 RFC7413 TCP Fast Open RFC7414 TCP Roadmap RFC8312 CUBIC , Linux's default congestion control algorithm since 2.6.19, replaced BIC (default from 2.6.8 till 2.6.18.x) Many others TCP/IP Implementations BSD family, BSD family tree 4.4BSD-Lite is convered in TCP/IP Illustrated (vol. 2): The Implementation by Gary R. Wright and W. Richard Stevens, 1995. FreeBSD http://www.f-stack.org/ User space TCP/IP stack from FreeBSD 11.0 Linux First in 0.98 by Ross Biro, net/tcp , 1992-09-29 Switched to a new one by Fred van Kempen in 0.99.10, net/inet , 1993-06-07 In 1.2.10 -> 1.3.0, moved from net/inet to net/ipv4 . Last update to net/inet was in 1.2.13 In 2.1.8, added net/ipv6 https://blog.cloudflare.com/why-we-use-the-linux-kernels-tcp-stack/ https://jvns.ca/blog/2016/06/30/why-do-we-use-the-linux-kernels-tcp-stack/ lwIP / uIP / picoTCP For microcontrollers, small footprint gvisor / netstack User space, in Golang Others, mostly user space https://shader.kaist.edu/mtcp/ http://seastar.io/networking/ Educational OSes Minix 2.x has its own TCP/IP stack, 3.x uses lwIP instead. Xinu code , covered in Internetworking With TCP/IP Volume II: Design, Implementation, and Internals, 3rd ed. by Douglas E. Comer and David L. Stevens, 1999. Toy implementations https://github.com/saminiir/level-ip Tools packetdrill is a unittest for entire TCP/IP stack. neper is a performance testing tool to generate workloads. Recent changes Recent changes that I am aware of. EDT netdev 0x12 Keynote : Evolving from AFAP: Teaching NICs about time by Van Jacobson , slides and video . Linux 4.20 switched to Early Departure Time model in 2018/09, and refined in 2018/10. Historical notes In 2004, Vinton Cerf and Robert Kahn received the ACM Turing Award for their foundational work on TCP/IP. A Protocol for Packet Network Intercommunication , May 1974.","title":"Home"},{"location":"#shuo-chens-notes-on-linux-tcpip-stack","text":"Source of this site: https://github.com/chenshuo/tcpip-study The TCP state machine has three","title":"Shuo Chen's notes on Linux TCP/IP stack"},{"location":"#tcpip-reference","text":"TCP/IP Illustrated (vol. 1): The Protocols, 2nd ed. by Kevin R. Fall and W. Richard Stevens , 2011/11. RFC793 Transmission Control Protocol, 1981/09 RFC896 Nagle algorithm, 1984/01. Minshall's update . RFC1122 Requirements for Internet Hosts --- Communication Layers, 1989/10 RFC5681 TCP Congestion Control, 2009/09 RFC6093 On the Implementation of the TCP Urgent Mechanism, 2011/01, which recommends against the use of urgent mechanism. RFC7323 TCP Extensions for High Performance, obsoletes RFC1323 RFC7413 TCP Fast Open RFC7414 TCP Roadmap RFC8312 CUBIC , Linux's default congestion control algorithm since 2.6.19, replaced BIC (default from 2.6.8 till 2.6.18.x) Many others","title":"TCP/IP Reference"},{"location":"#tcpip-implementations","text":"BSD family, BSD family tree 4.4BSD-Lite is convered in TCP/IP Illustrated (vol. 2): The Implementation by Gary R. Wright and W. Richard Stevens, 1995. FreeBSD http://www.f-stack.org/ User space TCP/IP stack from FreeBSD 11.0 Linux First in 0.98 by Ross Biro, net/tcp , 1992-09-29 Switched to a new one by Fred van Kempen in 0.99.10, net/inet , 1993-06-07 In 1.2.10 -> 1.3.0, moved from net/inet to net/ipv4 . Last update to net/inet was in 1.2.13 In 2.1.8, added net/ipv6 https://blog.cloudflare.com/why-we-use-the-linux-kernels-tcp-stack/ https://jvns.ca/blog/2016/06/30/why-do-we-use-the-linux-kernels-tcp-stack/ lwIP / uIP / picoTCP For microcontrollers, small footprint gvisor / netstack User space, in Golang Others, mostly user space https://shader.kaist.edu/mtcp/ http://seastar.io/networking/ Educational OSes Minix 2.x has its own TCP/IP stack, 3.x uses lwIP instead. Xinu code , covered in Internetworking With TCP/IP Volume II: Design, Implementation, and Internals, 3rd ed. by Douglas E. Comer and David L. Stevens, 1999. Toy implementations https://github.com/saminiir/level-ip","title":"TCP/IP Implementations"},{"location":"#tools","text":"packetdrill is a unittest for entire TCP/IP stack. neper is a performance testing tool to generate workloads.","title":"Tools"},{"location":"#recent-changes","text":"Recent changes that I am aware of. EDT netdev 0x12 Keynote : Evolving from AFAP: Teaching NICs about time by Van Jacobson , slides and video . Linux 4.20 switched to Early Departure Time model in 2018/09, and refined in 2018/10.","title":"Recent changes"},{"location":"#historical-notes","text":"In 2004, Vinton Cerf and Robert Kahn received the ACM Turing Award for their foundational work on TCP/IP. A Protocol for Packet Network Intercommunication , May 1974.","title":"Historical notes"},{"location":"links/","text":"Links Literatures I have or haven't read. Socksdirect: datacenter sockets can be fast and compatible , SIGCOMM '19. Busypolling next generation by Eric Dumazet, 2017. Making Linux TCP Fast by Yuchung Cheng and Neal Cardwell, 2016. paper Kernel Networking Walkthrough by Thomas Graf, LinuxCon 2015. Nice and short (~20 slides) intro to NAPI, RSS, RPS, GRO, TSO, FastOpen with pictures. TCP Implementation in Linux: A Brief Tutorial , 2008. Nice two-page overview of TCP/IP stack in Linux 2.6.19. Scaling in the Linux Networking Stack , kernel doc that describes RSS, RPS, RFS, XPS, etc. Programming with the Netpoll API by Jeff Moyer, Linux Kongress 2005. RFCs RFC3439 Some Internet Architectural Guidelines and Philosophy, 2002-12. \"Layering Considered Harmful.\" linked from Internet protocol suite RFC1958 Architectural Principles of the Internet, 1996-06. Posts Segmentation and Checksum Offloading: Turning Off with ethtool by Dr Steven Gordon, 2010 Reply from David Miller about capturing packets when GSO is on. https://calomel.org/network_loss_emulation.html https://spl0dge.wordpress.com/2013/09/08/building-a-wan-simulator/ https://web.archive.org/web/20160306040049/http://tdistler.com/2011/06/10/netem-wan-emulation-how-to-setup-a-netem-box","title":"Links"},{"location":"links/#links","text":"Literatures I have or haven't read. Socksdirect: datacenter sockets can be fast and compatible , SIGCOMM '19. Busypolling next generation by Eric Dumazet, 2017. Making Linux TCP Fast by Yuchung Cheng and Neal Cardwell, 2016. paper Kernel Networking Walkthrough by Thomas Graf, LinuxCon 2015. Nice and short (~20 slides) intro to NAPI, RSS, RPS, GRO, TSO, FastOpen with pictures. TCP Implementation in Linux: A Brief Tutorial , 2008. Nice two-page overview of TCP/IP stack in Linux 2.6.19. Scaling in the Linux Networking Stack , kernel doc that describes RSS, RPS, RFS, XPS, etc. Programming with the Netpoll API by Jeff Moyer, Linux Kongress 2005.","title":"Links"},{"location":"links/#rfcs","text":"RFC3439 Some Internet Architectural Guidelines and Philosophy, 2002-12. \"Layering Considered Harmful.\" linked from Internet protocol suite RFC1958 Architectural Principles of the Internet, 1996-06.","title":"RFCs"},{"location":"links/#posts","text":"Segmentation and Checksum Offloading: Turning Off with ethtool by Dr Steven Gordon, 2010 Reply from David Miller about capturing packets when GSO is on. https://calomel.org/network_loss_emulation.html https://spl0dge.wordpress.com/2013/09/08/building-a-wan-simulator/ https://web.archive.org/web/20160306040049/http://tdistler.com/2011/06/10/netem-wan-emulation-how-to-setup-a-netem-box","title":"Posts"},{"location":"profile/","text":"Profiling Linux TCP/IP stack with perf and pprof At home, I have two Linux hosts with Mellanox 10GbE nic (ConnectX EN 10GigE MT26448, bought used from Ebay in 2017) directly connected using SPF cable. Thoughput was about 1100MiB/s over 10GbE, both machine runs ~40% CPU utilization in one thread. For comparison, run openssl speed sha on the Rx side machine, an i7-3770 @ 3.4GHz. $ openssl speed sha OpenSSL 1.1.1f 31 Mar 2020 The 'numbers' are in 1000s of bytes per second processed. type 16 bytes 64 bytes 256 bytes 1024 bytes 8192 bytes 16384 bytes sha1 137355.08k 323943.17k 603290.54k 770941.95k 843352.75k 849619.63k sha256 75659.30k 167113.02k 289437.70k 354737.49k 379652.78k 381676.20k sha512 51745.33k 206941.63k 329443.07k 468301.82k 533897.22k 539525.12k In short, sending data through TCP is faster than calculating SHA1 locally. Rx is more expensive, it uses about 2x CPU cycles than Tx. Tx path Profile taken on Debian bullseye (testing, pre-release 11) w/ kernel 5.6.14. Run the chargen program to keep sending data to a discard server. Rx path Profile taken on Ubuntu 18.04 w/ kernel 4.15 Run the discard program to keep reading the socket. Loopback w/ IPv6 Profile taken on Ubuntu 20.04 w/ kernel 5.4. Run both chargen and discard on the same i7-3770 host, throughput was about 3300MiB/s. chargen ran at 100% CPU, discard was about 74%.","title":"Profiling"},{"location":"profile/#profiling-linux-tcpip-stack-with-perf-and-pprof","text":"At home, I have two Linux hosts with Mellanox 10GbE nic (ConnectX EN 10GigE MT26448, bought used from Ebay in 2017) directly connected using SPF cable. Thoughput was about 1100MiB/s over 10GbE, both machine runs ~40% CPU utilization in one thread. For comparison, run openssl speed sha on the Rx side machine, an i7-3770 @ 3.4GHz. $ openssl speed sha OpenSSL 1.1.1f 31 Mar 2020 The 'numbers' are in 1000s of bytes per second processed. type 16 bytes 64 bytes 256 bytes 1024 bytes 8192 bytes 16384 bytes sha1 137355.08k 323943.17k 603290.54k 770941.95k 843352.75k 849619.63k sha256 75659.30k 167113.02k 289437.70k 354737.49k 379652.78k 381676.20k sha512 51745.33k 206941.63k 329443.07k 468301.82k 533897.22k 539525.12k In short, sending data through TCP is faster than calculating SHA1 locally. Rx is more expensive, it uses about 2x CPU cycles than Tx.","title":"Profiling Linux TCP/IP stack with perf and pprof"},{"location":"profile/#tx-path","text":"Profile taken on Debian bullseye (testing, pre-release 11) w/ kernel 5.6.14. Run the chargen program to keep sending data to a discard server.","title":"Tx path"},{"location":"profile/#rx-path","text":"Profile taken on Ubuntu 18.04 w/ kernel 4.15 Run the discard program to keep reading the socket.","title":"Rx path"},{"location":"profile/#loopback-w-ipv6","text":"Profile taken on Ubuntu 20.04 w/ kernel 5.4. Run both chargen and discard on the same i7-3770 host, throughput was about 3300MiB/s. chargen ran at 100% CPU, discard was about 74%.","title":"Loopback w/ IPv6"},{"location":"walkthrough/","text":"Code Walkthrough Blocking write packetdrill/gtests/net/tcp/blocking/blocking-write.pkt // Test for blocking write. --tolerance_usecs=10000 `../common/defaults.sh ../common/set_sysctls.py /proc/sys/net/ipv4/tcp_min_tso_segs=10 ` // Establish a connection. 0 socket(..., SOCK_STREAM,PROTO_TCP) = 3 +0 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0 +0 bind(3, ..., ...) = 0 +0 listen(3, 1) = 0 +.1 < S 0:0(0) win 50000 <mss 1000,nop,wscale 0> +0 > S. 0:0(0) ack 1 <mss 1460,nop,wscale 8> +.1 < . 1:1(0) ack 1 win 50000 +0 accept(3, ..., ...) = 4 // Kernel doubles our value -> sk->sk_sndbuf is set to 42000 +0 setsockopt(4, SOL_SOCKET, SO_SNDBUF, [21000], 4) = 0 +0 getsockopt(4, SOL_SOCKET, SO_SNDBUF, [42000], [4]) = 0 // A write of 60000 does not block. +0...0.300 write(4, ..., 61000) = 61000 // this write() blocks +.1 < . 1:1(0) ack 10001 win 50000 +.1 < . 1:1(0) ack 30001 win 50000 // This ACK should wakeup the write(). An ACK of 35001 does not. +.1 < . 1:1(0) ack 36001 win 50000 // Reset to sysctls defaults. `/tmp/sysctl_restore_${PPID}.sh` tcpdump -i any -n -ttt tcp port 8080 // Three-way handshake 1 0.000000 remote:54321 > local:8080: [S], seq 0, win 50000, options [mss 1000,nop,wscale 0], length 0 2 0.000640 local:8080 > remote:54321: [S.], seq 12345, ack 1, win 65535, options [mss 1460,nop,wscale 8], length 0 3 0.111259 remote:54321 > local:8080: [.], ack 1, win 50000, length 0 // cwnd = 10, mss = 1000, so send 10 * 1000 then wait for ACK. 4 0.017588 local:8080 > remote:54321: [P.], seq 1:5001, ack 1, win 256, length 5000 5 0.000199 local:8080 > remote:54321: [P.], seq 5001:10001, ack 1, win 256, length 5000 6 0.101236 remote:54321 > local:8080: [.], ack 10001, win 50000, length 0 // slow-start, increase cwnd per ACK. cwnd = 20, so send 20 * 1000 then wait for ACK. 7 0.000573 local:8080 > remote:54321: [P.], seq 10001:20001, ack 1, win 256, length 10000 8 0.000276 local:8080 > remote:54321: [P.], seq 20001:30001, ack 1, win 256, length 10000 9 0.099876 remote:54321 > local:8080: [.], ack 30001, win 50000, length 0 // slow-start, again. write() now blocks. 10 0.000490 local:8080 > remote:54321: [P.], seq 30001:35001, ack 1, win 256, length 5000 11 0.000456 local:8080 > remote:54321: [P.], seq 35001:45001, ack 1, win 256, length 10000 12 0.000182 local:8080 > remote:54321: [P.], seq 45001:55001, ack 1, win 256, length 10000 13 0.000157 local:8080 > remote:54321: [P.], seq 55001:60001, ack 1, win 256, length 5000 14 0.098661 remote:54321 > local:8080: [.], ack 36001, win 50000, length 0 // the previous ACK unblocks write(). 15 0.001139 local:8080 > remote:54321: [P.], seq 60001:61001, ack 1, win 256, length 1000 16 0.325737 local:8080 > remote:54321: [.], seq 36001:37001, ack 1, win 256, length 1000 // Re-xmit 17 0.038498 local:8080 > remote:54321: [F.], seq 61001, ack 1, win 256, length 0","title":"Walkthrough"},{"location":"walkthrough/#code-walkthrough","text":"","title":"Code Walkthrough"},{"location":"walkthrough/#blocking-write","text":"packetdrill/gtests/net/tcp/blocking/blocking-write.pkt // Test for blocking write. --tolerance_usecs=10000 `../common/defaults.sh ../common/set_sysctls.py /proc/sys/net/ipv4/tcp_min_tso_segs=10 ` // Establish a connection. 0 socket(..., SOCK_STREAM,PROTO_TCP) = 3 +0 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0 +0 bind(3, ..., ...) = 0 +0 listen(3, 1) = 0 +.1 < S 0:0(0) win 50000 <mss 1000,nop,wscale 0> +0 > S. 0:0(0) ack 1 <mss 1460,nop,wscale 8> +.1 < . 1:1(0) ack 1 win 50000 +0 accept(3, ..., ...) = 4 // Kernel doubles our value -> sk->sk_sndbuf is set to 42000 +0 setsockopt(4, SOL_SOCKET, SO_SNDBUF, [21000], 4) = 0 +0 getsockopt(4, SOL_SOCKET, SO_SNDBUF, [42000], [4]) = 0 // A write of 60000 does not block. +0...0.300 write(4, ..., 61000) = 61000 // this write() blocks +.1 < . 1:1(0) ack 10001 win 50000 +.1 < . 1:1(0) ack 30001 win 50000 // This ACK should wakeup the write(). An ACK of 35001 does not. +.1 < . 1:1(0) ack 36001 win 50000 // Reset to sysctls defaults. `/tmp/sysctl_restore_${PPID}.sh` tcpdump -i any -n -ttt tcp port 8080 // Three-way handshake 1 0.000000 remote:54321 > local:8080: [S], seq 0, win 50000, options [mss 1000,nop,wscale 0], length 0 2 0.000640 local:8080 > remote:54321: [S.], seq 12345, ack 1, win 65535, options [mss 1460,nop,wscale 8], length 0 3 0.111259 remote:54321 > local:8080: [.], ack 1, win 50000, length 0 // cwnd = 10, mss = 1000, so send 10 * 1000 then wait for ACK. 4 0.017588 local:8080 > remote:54321: [P.], seq 1:5001, ack 1, win 256, length 5000 5 0.000199 local:8080 > remote:54321: [P.], seq 5001:10001, ack 1, win 256, length 5000 6 0.101236 remote:54321 > local:8080: [.], ack 10001, win 50000, length 0 // slow-start, increase cwnd per ACK. cwnd = 20, so send 20 * 1000 then wait for ACK. 7 0.000573 local:8080 > remote:54321: [P.], seq 10001:20001, ack 1, win 256, length 10000 8 0.000276 local:8080 > remote:54321: [P.], seq 20001:30001, ack 1, win 256, length 10000 9 0.099876 remote:54321 > local:8080: [.], ack 30001, win 50000, length 0 // slow-start, again. write() now blocks. 10 0.000490 local:8080 > remote:54321: [P.], seq 30001:35001, ack 1, win 256, length 5000 11 0.000456 local:8080 > remote:54321: [P.], seq 35001:45001, ack 1, win 256, length 10000 12 0.000182 local:8080 > remote:54321: [P.], seq 45001:55001, ack 1, win 256, length 10000 13 0.000157 local:8080 > remote:54321: [P.], seq 55001:60001, ack 1, win 256, length 5000 14 0.098661 remote:54321 > local:8080: [.], ack 36001, win 50000, length 0 // the previous ACK unblocks write(). 15 0.001139 local:8080 > remote:54321: [P.], seq 60001:61001, ack 1, win 256, length 1000 16 0.325737 local:8080 > remote:54321: [.], seq 36001:37001, ack 1, win 256, length 1000 // Re-xmit 17 0.038498 local:8080 > remote:54321: [F.], seq 61001, ack 1, win 256, length 0","title":"Blocking write"}]}